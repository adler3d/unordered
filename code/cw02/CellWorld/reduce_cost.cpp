//need to reduce the cost of calling a function get_depends_points
vector<map_frag> frags;

теперь нужно сделать обратную фунцию.

даём на вход функцию которая говорит какие точки сейчас уже проверены.
на выходе получаем список фрагментов.

void go(const vector<cell_point>&points,const vector<int>&inp,vector<int>&out)
{
  
}

rule.eval(view,result);


короче мы можем сохранить внтри машины контекст каждого правила.
затем когда нам нужно будет проделать следующий шаг, мы просто дадим правилу контекст.
правило сделает мальнький шажок. изменит контекст. мы получим его реакцию.

правило.шаг(контекст_правила);

одно правило зависит от нескольких других.
можно их контекст класть внутрь контекста нашего правила. :)


тупо в лоб делать опасно.

вот те методы которые считают количество путей их нужно сделать умнее.
надо чтобы функция прекращала выполнение сразу же как только кол-во путей больше чем надо.
или нет?
для уменьшения стоимости вызова функции да, надо передавать парамет и выходить как можно быстрее, для отладки нет.

надо как-то учитывать, что порядок в котором выполнятся проверки зависимых путей неважен.
возможно это помет уменьшить стоимость вызова функции.

struct context

rule.start(context);
rule.step(context,out);
rule.stop(context);

struct t_machine{
  
} machine;

rule.eval_by_steps(view,machine);

суть.

потом, мы всёравно отсеим все варианты, которые нас не интересуют. тоесть те которые не изменяют состояние ячейки.

out.ok
out.type

GBX



