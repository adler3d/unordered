
Какой-то мега крутой язык. шаблоны круче чем В С++
{
  неявная куча.
  шаблоны.
  вложенныее структуры и функции.
  векторы.
  строки.
  динамическое выделение памяти.
}

C++ подобный язык без векторов.
{
  нет векторов.
  нет строк.
  нет внешней кучи.
  все типы фиксированного размера.
  нет шаблонов?
  есть выражения любой сложности.
  есть перегруженные функции.
}

int foo(int a,int b){
  int c=0;
  c=a;
  for(int i=0;i<4;i++){
    c=mul(b+i,2);
  }
  return c;
}

Урезанный С++.
{
  составные математические выражения не поддерживаються.
  один статамент = один вызов функции.
  вложенные типы и функции запрещены.
  есть циклы.
  функции вызываються по их точному имени? или можно использовать перегрузку функций?
}

короче тут можно ещё один язык придумать.
чуть выше язык, где есть перегрузка функций.
а чуть ниже язык где её уже нет.
тоесть по имени функции сразу понятно что вызвать. тоесть типы параметров продублированны в имени функции.
тоесть по имении функции можно сразу определить какого типа параметры её требуються.

int foo(int a,int b){
  int c=0;
  c=a;
  for(int i=0;i<4;i++){
    int bi=b+i;
    c=mul(bi,2);
  }
  return c;
}

Асм аналог урезанного С++
{
  выражения вообще запрещены. теперь есть только инструкции.
  функции вызываються инструкцией call.
  вызов функции умный.
  нет цыклов.
  есть метки и безусловные переходы.
  соглашение о вызове функций:
  {
    M+=call
    M+=пробел
    M+=имя_функции
    M+=пробел
    M+=регистр_под_результат
    O+=
    {
      M+=пробел
      M+=параметры_разделённые_пробелом
    }
  }
  имя_функции однозначно определяет связку_параметров.(конкретное кол-во параметров конкретного типа)
  гг
}

"int",foo("int" a,"int" b),asm{
  "int" c;
  "int" i;
  "int" bi;
  "bool" flag;
  ---
  "int"mov c a;
loop:
  "int"mov i 0;
cond:
  "int"less flag i 4
  jnz flag body
  jmp end
body:
  "int"add bi b i
  call "int mul(int,int)" c bi 2
next:
  inc i
  jmp cond
end:
  ret c
}

не семетрично урезанный асм
{
  соглашение о вызове функций:
  {
    M+=call
    M+=пробел
    M+=имя_функции
    M+=пробел
    M+=регистр_под_результат
    M+=пробел
    M+=регистр_с_параметрами
  }
  прототип функции содержит столько параметров сколько захотел автор.
  тоесть этот асм не семетричный. все функции вызываються с одним параметром, а во время выполнения они считают что у них может быть несколько параметров.
  тоесть интерпретатор перед вызовом функции распоковывает регистр_с_параметрами и раскладывает его по параметрам.
  но тут есть проблемма.
  нужно раскладывать очень окуратно. и складывать в регистр_с_параметрами тоже нужно аккуратно.
  особенно интересный вопрос что делать с строками и векторами.
  надо написать отделную пачку функций и посмотреть как всё будет работать.
}

"int",foo("int" a,"int" b),asm{
  "int" c;
  "int" i;
  "int" bi;
  "bool" flag;
  "array{int,2}" params;
  ---
  "int"mov c a;
loop:
  "int"mov i 0;
cond:
  "int"less flag i 4
  jnz flag body
  jmp end
body:
  "int"add bi b i
  "int"mov params[0] a
  "int"mov params[1] b
  call "int mul(int,int)" c params
next:
  inc i
  jmp cond
end:
  ret c
}

симетрично урезанный асм. весрия 1.0
{
  описание функция
  {
    тип_возвращаемого_значения?? как насчёт string,vector{int},struct можно нет?
    уникальное_имя_функции
    тип_принимаемого_значения?? как насчёт string,vector{int},struct можно нет?
  }
}

"int","int foo(int,int)","array{int,2}",asm{
  .a 0
  .b 1
  ---
  "int" a;
  "int" b;
  "int" c;
  "int" i;
  "int" bi;
  "bool" flag;
  ---
  "int"mov a inp[.a];
  "int"mov b inp[.b];
  "int"mov c a;
loop:
  "int"mov i 0;
cond:
  "int"less flag i 4
  jnz flag body
  jmp end
body:
  "int"add bi b i
  "int"mov params[0] a
  "int"mov params[1] b
  call "int mul(int,int)" c params
next:
  inc i
  jmp cond
end:
  ret c
}

симетрично урезанный асм. версия 2.0
{
  входные и выходные парамерты не имеют типа вообще. только размер.
  плюсы: нит
  минусы: не ясен формат содержимого внутри регистра_с_параметрами.
}

"int foo(int,int)",1,2,asm{
  .a 0
  .b 1
  ---
  "int" a;
  "int" b;
  "int" c;
  "int" i;
  "int" bi;
  "bool" flag;
  ---
  "int"mov a inp[.a];
  "int"mov b inp[.b];
  "int"mov c a;
loop:
  "int"mov i 0;
cond:
  "int"less flag i 4
  jnz flag body
  jmp end
body:
  "int"add bi b i
  "int"mov params[0] a
  "int"mov params[1] b
  call "int mul(int,int)" c params
next:
  inc i
  jmp cond
end:
  ret c
}

симетрично урезанный асм. версия 3.0
{
  тот самый уровень где типов больше нет вообще.
  есть только массивы биты разного размера.
}

"int foo(int,int)",1:"int",2:"???",asm{...}