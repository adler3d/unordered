

методы изменяющие объект и возвращающие что-то полезное.

конструкторы и деструкторы.
{
  сейчас конструкторы и деструкторы отсутсвуют.
  а мне нравиться использовать деструкторы чтобы после выхода из области видимости сделать какую-то работу.
  я не могу от этого отказаться?
  если вектор реализовать как пользовательский тип. то как он будет освобождать память?
  тупик. и непонимание.
}





структуры.
вектор интов.

прямой доступ к памяти. но нет встройного вектора и компилятора оптимизаирующего копирования. // совместимость с С++ и asm`мом и нативным кодом. быстрая скорость выполнения на существующих ЦПУ.
{
  если я не сделаю это, то тогда дойду до битовой адресации и оптимизирующих структур.
  но весь код придёться писать на обычном С++ а не на своём. всё из-за того, что свой яп будет медленно выполняться из-за битовой адресации.точнее из-за отсутствия хардварной поддержки таких операций.
  
  могу ли я сделать свой яп без битовой адресации? да, но он будет не таким хорошим.
  точнее это будет полное говно ничем не отличающееся от обычных ЯП.
  
  зато код можно будет транслировать в нативный и выполнять с такой же скоростью.
  но из-за того. что яп будет обещать оптимизировать копирования и встаривать оптимизирующее структуры,
    а пофакту будет делать всё тупо в лоб и просрёт на этом всю производительность.
  это будет никому не нужный яп. его нет смысла делать пока я не научусь устранять избыточные копирования.
  если его нужно сделать, для того чтобы научиться устронять избыточные копирования. то я его сделаю и научусь.
  
  после устранения копирований яп обретёт право на жизьнь и развитие.
  но если в неём будет только битовая адресация - то он наверно права на жизьн не получит вообще.
  если только как яп для какой-то игры в которой надо что-то програмировать. тогда это win.
  ведь там на производительность всем насрать. точнее добиться такого состояния от людей проще.
  
  теперь про прямой доступ.
  вообще я планиру разрешить грузить машкод из инета и отправлять его на выполнене в vm.
  толко нужно проверять выход за границы песочнецы. а то кто-то из инета получит доступ к ПК.
  
  и что с этого? то что можно спокойно разрешать тогда писать проги на С++ подобном языке который
  позволяет напрямую писать в память vm.
  тогда вектор станет не встроеным, а пользовательским шаблоном.
  
  тоесть мне придёться делать поддержку шаблонов. а мне всё равно её надо делать. но я планировал её сделать потом.
  
  самое плохое. что мне придёться делать всё это ебучие const*& && говно.
  но код станет ближе к С++ и Си.
  
  или придумать какоую-то замену этому говно. тогда потеряетсья совместимость.
  но ни о какой оптимизации копирования речи нет. т.к всюду мутабельное говно.
  вот так с ходу я не верею что смогу сделать оптимизацию копирования в коде с мутабельным говном.
  можно конечно проследить где мутабельного говна нет и сделать оптимизацию.
  но кто будет писать такой код? никто.
  никто не будет пологаться на компилятор в надежде что он оптимизирует копирования. если этого нигде никто не обещает.
  всем нужен результат прям сдесь и сейчас. поэтомц везде говнокод.
  
  блин ну и чё делать.
  не хочу писать поддержку констант. т.к это привратит всё в говно. она меня бесит своей сложностью.
  если я е сделаю, то тогда потом год не захочу никакие ЯП писать. а может и больше.
  
  а ещё есть шанс что я вообще не смогу её сделать, но он маленький.
  
  а без этого говна вообще не понятно как быть.
  
  ладно на const можно положить болт, но от этого будет много проблем для прогеров.
  
  блин я могу сделать просто нахуй функцию которая будет давать доступ к памяти и всё бляд.
  ИНТЕРЕСНОЕ РЕШЕНИЕ, ПРОСТО ФУНКЦИЯ ДЛЯ ДОСТУПА К ПАМЯТИ.
  
  но как быть с оператором котрый должен возвращать
  объект доступный для изменения?
  как быть с методами, которые должны изменять объект.
  
  можно сделать так, чтобы они возвращали сами себя.
  тоесть результат вызова метода - это всегда объект у которого его вызвали, только модифицированный самим методом.
  но тогда нельзя будет сделать метод который изменит объект и ещё вернёт что-то полезное.
}

нет прямого доступа к памяти. но есть встройный вектор. и копилятор оптимизаирующий копирования. // хочу. кртой ЯП. должен уделать С++. Но нужны новые ЦПУ. иначе fail.
{
  этот язык всё равно победит.
  т.к может компилировать код под любую платформу.
  но под свою платформу он компилит код ещё круче. достигя теоретических пределов.
  
  код красивый. т.к нет прямого доступа памяти, а все оптимизации делает компилятор.
  но и GC тоже нет.
  
  проге пишет код с изобилием копирований а компилятор их убирает.
  можно так и написать что копилятор должен убирать все теоретически не нужны копирования.
  и ввести такое понятие как качество соотвествия компилятора стандарту на основе того как он оптимизирует копирования.
  и умеет ли он внедрят оптимизирующеие структуры туда где их небыло, но где они разрешены стандартом.
  
  этот яп - полигон для испытания создателей оптимизироующих компиляторов.
}






















с премером кода я разабрался. что теперь.
я могу вручную написать то во что он должен транслироваться.
вообще т.к вектор интов это структура, то есть смысл сначала сделать поддержку структур
и только потом делать поддержку векторов.
да всё так.

но с другой стороны. вектор системная структура.
тоесть до её полей добраться невозможно.
иначе можно будет получить доступ к памяти.
а я его собрался ограничить.

но если я его ограничу, то тогда некоторые вещи придёться делать по другому.

вообще идея запретить запись в память - это удар по произодительности и запрет на оптимизацию.

с одной стороны мне нужен язык и компилятор которого будет сам всё оптимизировать.
тоесть он будет монополистом в области оптимизации.
програмист не будет иметь возможности влиять на скорость выполнения.
она всегда будет максимизироваться.

а с другой стороны мне нужен яп, типа с++. чтобы был прямой доступ к памят.
и чтобы он компилировался в код для существующий процов а не вымышленных.

если давать прямой доступ, то тогда будет яп для говнокода.
если не делать, то будет яп для прототипов.


пример проги которая будет использовать вектор интов
{
  сделал. но говно.
  сделать круче?
  просто очевидно, что к тому моменту когда я сделаю компилятор для этого
  кода желания придумывать пример никак не измениться.
  точнее даже сказать нежелание.
  более того, это не желание будет сопровождать меня каждую секунду написания компилятора.
  а вот если написать крутую прогу, то тогда желание написать компилятор для неё увеличиться.
  и когда я его напишу, то просто возьму и скомпилирую её и буду смотреть на результат.
  здорово же!
  
  сгенерирова картинку? но не из пикселей?
  у меня же уже сть демка. вот её и можно использовать.
  или там всё на real`ах? да. точно там всё основано на числах с плавающей запятой.
  
  с той прогой всё впорядке.
  я реально могу рисовать какое угодно говно не используя FPU.
  Я МОГУ СДЕЛАТЬ ТРИАНГУЛЯЦИЮ БЕЗ FPU на своём ЯП компилирующуюся в байткод для своей VM!
  Я могу сделать редактор 2д контуров.. точнее переписать его с С++.
  
  блин. реально круто.
  но для начала надо сделать чтобы хотябы катмулром сплайны рисовались.
  точно.
  
  чтобы выводить что-то сложное в больших кол-вах нужно делать поддержку структур в трансляторе.
  а можно для начала просто генерировать линии на выход.
  и сделать простенькую отрисовку линий.
}
