vector{char} memory;

struct t_chunk{
  int pos;
  int size;
  bool used;
  int next;
  int prev;
}

raw_ptr{t_chunk,int} next;
raw_ptr{t_chunk,int} prev;

t_chunk next=chunk.next.get(memory);

t_chunk get(vector{char} memory,t_chunk_ptr ptr){
  t_chunk tmp;
  auto arr=memory.subarr(ptr.value,sizeof(t_chunk));
  tmp.fromBlob(arr);
  return tmp;
}

t_chunk next=get(memory,chunk.next);



сделать двусязанвый список в памяти массива байт на своём скрипте.

жопа.
пул объектов одинакового размера работает быстро, а вот куча из объектов не пойми какого размера-медленее.

короче проблемма в том, что не известно какого размера объекты нужно будет выделить в куче.
поэтому обычный пул не подойдёт.
получаеться надо сделать целый массив пулов разных размеров.
2,4,8,16,32,64,128,256,512,1024,2048,...

потом выбирать нужный пул из нужного массива и использовать.

тоесть если нам надо 1килобайт, то мы берем пул на килобайт и выделяем из него один элемент.


итак... у нас есть память.

короче идея такая. веделяем массив на 1024*1024*16 байт.

дальше надо сделать заголовок для него.

короче как ни крути, а придёться делать двусвязаный список.
короче вся память будет делиться на кусочки.
каждый кусочек имеет свой размер.
кусочек можно разбить на мелкие кусочки.
но тогда мне придёться их сшивать.

ок. сшивать так сшивать.




вот это попец настал.
оказываеться я не могу предоставить доступ к элементам строки, т.к внутри строки нет t_expr::i_value
как же быть. передалать весь интерфейс так, чтобы он начал работать только с сырыми данными.
просто сейчас он с сырыми данными не работает вообще.
из-за этого у меня скрипт работает медленно.

короче осноная задача: сделать байткод способный работать с векторами.

нет. байткод не должен работать с векторами. он не должен ничего знать про векторы.
короче должна быть память скрипта. в этой памяти будет организована куча.
и все векторы и строки будут в этой кучу.
массивы - нет. массивы фиксированного размер могут быть прям на стеке.
тоесть они вообще могут быть реализованы железно.

тоесть массив - это что-то типа одного регистра.
но это особенный регист из которого можно читать память кусочками.
и записывать в него тоже кусочками.

array{char,1024*1024*16} mem;
vector_int arr;
arr.resize(mem,1);
arr.resize(mem,0);

mem - сделан не правильно.

надо чтобы была куча.

t_heap{array{char,1024*1024*16}} heap;

vector{int} arr;
arr.resize(heap,1);
arr[0]=1; //fail. дело в том, что тут не указана куча. куча может быть не одна. нажно чтобы куча была однозначо определена.
arr.set(heap,0,1); //говно? да!
arr[heap,0]=1; //говно? уже лучше. но постоянно указывать кучу - можно сума сойти. нафиг её указывать если она всегда одна и также? как быть?
arr.resize(heap,0);
foo(arr); //а вот так? мы там ничего не сможем записать внутрь вектора, т.к кучу нам не дали. нам теперь что нужно туда кучу передовать?
foo(heap,arr); //норм? но тогда внутри функции нам могут засрать всю кучу говно, что делать-то?

так. а где сам vector{int} находиться? он что вне кучи?
он на стеке, но его можна записать в кучу или прочитать из кучи.
вообще vector{int} - это тип регистра. тоесть он может быть не на стеке, а внутри регистра.
так... а что делать с кучей. не могу же я постоянно везде её упоминать.
если я сделаю так, чтобы её всегда нужно будет указывать, то тогда на мой язык будут смотреть как на говно.

можно попробовать для начала сделать именно так.
тоесть везде всегда указывать кучу.
а потом придумать синтаксический сахор, который будет скрывать кучу. но изначально он конечно не нужен и вреден.
я должен видет то, что спрятано за ним. а том я столько лет писал код и даже не задумывался над тем, что он скрывает одну важную деталь.

так. вообще все инструменты для тестирования кучи у меня уже вроде готовы, так?
я могу работать с массивами и с числами. а больше вроде ничего и не надо.

так. вообще тут есть проблема.

foo(heap,arr); может только читать память из кучи, но не может в неё писать. вот такое он говно.
это печально. для того, чтобы он мог писать в кучу мы должны сделать вот так.

heap=foo(heap,arr); да, я знаю это очень смешно, но это правда.
вообще heap - это один большой регистр.

вообще мне нравиться идея больших регистров.

тоесть процессор читает из внешней памяти кусок данных в один большой регистр.
затем он делает какие-то там свои собственные вычисления и изменяет весь регист.
а затем записывает значение из регистра в внешную память.
так. стоп. внешняя память? какя внешняя память. нет никакой внешней памяти.
есть только регистры. короче у процессора есть регистры ввода-вывода.
и процессор может записать что-то в один из таких регистров.
подожать получения подтверждения, а затем просто записать туда что-то новое.
вот и всё.



heap=foo(heap,arr); вот такая функция не может изменить размер вектора.
но она может изменить размер временного вектора. и тем самым испортить вектор.
короче такая функция может испортить кучу.
а это плохо.

а что делать если надо изменить и вектор и кучу.

struct t_foo_retval{
  //t_heap{array{char,1024*1024*16}} heap;
  t_heap heap;
  vector{int} arr;
}
t_foo_retval ret=foo(heap,arr);
heap=ret.heap;
arr=ret.arr;

методы это просто синтаксичейский сахар.
надо посмотреть как всё это выглядит горькая правда.

короче похоже у нас будет какой-то глобальный объект который мы будем постоянно переписывать.
он будет фиксированного размера.

t_obj obj;

obj=foo(obj); это плохо. функция изменяет весь глобальный объект.
хотя автор функции наверняка хотел изменить только часть объекта.

так тоесть проблемма такая.
да у нас есть большой объект который мы меняем при вызове каждой функции.
но автор функции видит смысл только в изменении небольшой части объекта.
тоесть те изменения которые происходят с остальной частью объекта - автоматические.
автор функции не следит за ними. ему они не интересны в рамках его функции.
когда автор пишит функцию он не думает об этих изменениях.

тоесть если автор внутри функции измени размер своего вектора, то он изменил глобальный объект.
но автор не хочет думать о глобальном объекте.
его интересует только его вектор и поле глобального объекта.

автору функции можн помочь если разделить глобальный объект на две части.
одна часть это то что интересно разработчику функций.
и вторая часть, то что не интересно.
тоесть автор хотел бы ничего не знать про вторую часть глобального объекта.

но проблемма в том, что та часть что интересует разработчика полностью находиться в памяти
той части которую разработчик знать не хочет.


t_heap foo(t_heap heap){
  
}

так. надо придумать простой пример.

есть вектор.
надо изменить его размер?
надо вернуть елемент вектора?
надо вернуть некоторые элементы из вектора?
надо вернуть другой вектор?
надо вернуть его размер?
надо смешать два вектора?
надо обработать какой-то функцией каждый элемент вектора? независимо => можно паралелить?

есть два вектора, надо выкинуть из него некоторые элементы.
это изменит размер вектора?
это изменит кучу.
годная задача.
мне нравиться.

string join(vector{string} arr,string glue){
  bool bool(int i){return i!=0;}
  string out;
  for(int i=0;i<arr.size();i++){
    if(bool(i))out+=glue;
    out+=arr[i];
  }
  return out;
}

vector{string} split(string s,string needle)
{
  vector{string} arr;
  auto p=0;
  for(;;){
    auto pos=StrFind(s,needle,p);
    if(pos<0){arr.push_back(StrSubStr(s,p,s.size()-p));return arr;}
    arr.push_back(StrSubStr(s,p,pos-p));
    p=pos+needle.size();
  }
  return arr;
}

vector{int} load(string s){
  return load(split(s," "));
}

vector{int} load(vector{string} arr){
  vector{int} out;
  for(int i=0;i<arr.size();i++)out.push_back(__SToI(arr[i]));
  return out;
}

vector{int} clean(vector{int} arr){
  vector{int} out;
  for(int i=0;i<arr.size();i++)if(arr[i]>0)out.push_back(arr[i]);
  return out;
}

итак. это довольно интересная задача.
она изменяет элементы вектора.
она изменяет размер вектора.
короче она изменяет кучу.

t_heap clean(heap,arr);

вообще если принять во внимание кучу, то тогда как быть с копированием вектора.
ведь получаеться кто-то может скопировать вектор. и тогда вектор будет рассинхронезирован с кучей.
и тогда это приведёт к неожиданному поведению программы.
можно считать вектор просто указателем на кучу.
тогда изменение размера не потребует изменение указателя.
но тогда придёться создавать и удалять векторы.
и ещё придёться защизать их от копирования.
а я так хотел сделать язык в котором копирование нельзя запретить.
а тут вдруг получаеться что нужно запрещать.
можно перегрузить оператор копирования.
тогда копирование вектора выделит в куче новый вектор.

тоесть в функцию мы будет передовать не указатель на старый вектор, а указатель на новый вектор.
а после завершения работы функции мы удалим новый вектор.

но это изменит кучу. куча будет не такой как до вызова функции.

как же автор алгоритма сможет указать то, что ему пофиг удет копирование содержимого вектора или нет.

тоесть автору алгоритма пофигу на процессы происходящие в куче.

vector{int} p; типизированый указатель на вектор в куче. тоесть там в куче будет указан размер вектора.
и указатель на чанк в котором содержимое вектора.

так. стоп! Указатель на чанк?
я предлагаю сделать внутри кучи древовидную фиговину.
тоесть мы выделяем чанк. и он выделяеться из дерева.

фишка дерева в том, что можно очень мелко нарезать всю память.
мину в том, что работает медленно.

можно сделать просто массив из чанков одинакового размера внутри кучи.
но тогда не получитсья выделить большой кусок памяти.




array{char,1024} foo(array{char,1024} inp)
{
  struct t_inp{int c;vec3c color;}
  t_inp tmp;
  tmp.fromBlob(inp);
  
}


так простое решение которое решает почти все проблемы:
любой вызов функции превращаем в вызов функции которая принимает и возвращает массив фиксированного размера.

если на любой вызов функции смотреть с такой точки зрения, то тогда имплементация функция может
не использовать векторы вообще.

короче нужно признать что я слишком рано сделал векторы.
векторы всё ещё не нужны.

vector{int} arr;

struct t_node{
  vector{t_node} arr;
}

t_node root; //-вот это очень странная вещь.

vector{int} a=gen(); //это короткая запись.

vector{int} a;
{
  t_heap heap;
  t_heap out=gen(heap);
  a.fromBlob(g_heap,out);
}

типа при работе с массивом никаких проблемм нет и куча не используеться.
тоесть это что-то такое отдельное?
ага, отдельное.
для каждого массива есть свой набор инструкций. и свой набор регистров.
тоесть массив можно загрузить из кучи в регистр.
а затем большой массив разбить на мелкие. перетащив его значение в мелкие регистры если надо.

для начала мне нужно научить асм работать с массивами.

массив - это целый тип. значит для него нужно делать инструкции.
скопировать весь массив.
достать элемент массива.

нужно ворочить массивами как значеним регистра.

















