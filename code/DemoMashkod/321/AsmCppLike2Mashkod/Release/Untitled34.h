так я делаю поддержку струутур в первом приблежении.

я делаю лексему разбирающую структуру в первом приблежении.

t_simple_stat_lex{
  t_struct{
    t_field{
      t_sep sep0;
      t_var_stat::t_impl body;
      t_sep sep1;
      {
        O+=go_auto(sep0);
        M+=go_auto(body);
        M+=go_const(";");
        O+=go_auto(sep1);
      }
    }
    t_method{
      t_sep sep0;
      t_func_stat::t_impl body;
      t_sep sep1;
      {
        O+=go_auto(sep0);
        M+=go_auto(body);
        O+=go_auto(sep1);
      }
    }
    t_sep sep0;
    t_name name;
    t_sep sep1;
    vector<t_sep_struct> arr;
    vector<t_field> fields;
    vector<t_method> methods;
    {
      M+=go_const("struct");
      M+=go_auto(sep0);
      M+=go_auto(name);
      O+=go_auto(sep1);
      M+=go_const("{");
      O+=go_auto(arr);
      O+=go_auto(fields);
      O+=go_auto(methods);
      M+=go_const("}");
    }
  }
  t_sep_struct{
    t_sep sep0;
    t_struct body;
    t_sep sep1;
    {
      O+=go_auto(sep0);
      M+=go_auto(body);
      O+=go_auto(sep1);
    }
  }
  t_struct_stat=>i_stat{
    t_struct body;
    {
      go_auto(body);
    }
  }
}

struct vec2d{
  struct t_other{};
  real x;
  real y;
  vec2d inv(){return vec2d(-x,-y);}
  void foo()={
    this.x=10;
  }
  static real get_x(vec2d v){
    return v.x;
  }
}

vec2d t=vec2d(0,1);
t=t.inv();

надо разобраться с тем, сразу делать методы или нет?
ещё новая задача:
сделать поддержку вот таких функций:
string foo(){
  int ee=10;
}

можно их всех пихать в t_full_stat_dev.
но тогда любой цикл создаст сотни таких типов - плохо.

что с операторми что с функциями что с структурами - одна и также проблемма.
они внутри цыкла будут по нескольку раз определены.
короче я предлагаю хитрое решение:
вообще игнорировать их во время выполнения.
и сделать дополнительный посетитель который будет искать функции в AST
и сделать чтобы t_full_stat_dev знал свой путь до функции которую он сейчас выполняет.


нужно ли делать typedef?

вообще как-то сложно определиться. с одной стороны typedef - это хорошо.
можно писать меньше кода. а вот с другой - полный провал.
static auto TSelfClass:=vec2d;
так. я помню мне хотелось иметь возможность знать как объявлено поле.
это нужно было для того, чтобы потом можно было бы сгенерировать исходный код из
той информации которая есть во время выполнения.
тоесть мне хотелось чтобы у меня во время выполнения было столько же информации сколько и во время
компиляции.
короче говоря я не увидел смысла в том, чтобы после компиляции забывать об исходной коде программы.
исходный код программы это вообще-то и есть документаций по программе.
и если программа во время выполнения может использовать свой исходный код, то она от этого только выигрывает в глазах пользователя.

но вообще можно забить на typedef. можно вместо него использовать using.
using abc=qap;


так у меня есть два пути:
сделать поддержку оператора точка.
сделать регестрацию новых типов.
