так. можно сейчас просто написать лексер для языка и интерпретатор его.
это заёмет где-то 2.5 часа.

struct vec2i{
  int x;
  int y;
}

struct t_buff{
  array{int,16} arr;
}

так. пока нет вектором(динамических массивов,массивов переменной длинны)
можно использовать внутри инструкции "call" доступ к элементу массива.
как на чтение так и на запись.
это вроде не должно мешать.

а это будет транслировать в нискоуровневый асм? вроде да.

так. прошло 35 минут а я ещё не написал не одной лексемы.
нужно исправить ситуацию.
план такой.
я 25 минут создаю первый набор лексем затем иду есть, а потом отдыхать.
после пробую создать ещё лексем.
затем снова отдыхать.
затем пробую проверить как всё это работает.
далше план не разборчивый.

t_buff "t_buff"(t_buff buff,int i,int value)asm
{
  var array{int,16} arr
  call "mov" arr buf.arr
  call "mov" arr[i] value; - add loop for i
  call "mov" buf.arr arr
  ret buff
}

t_buff "t_buff"(int value)asm
{
  var t_buff buff
  {
    var int i
    init:
    {
      call "mov" i 0
    }
    loop:
    {
      var bool flag;
      call "less" flag i buff.arr.size; - not ok
      jz flag end
    }
    body:
    {
      call "buff_set_at" buff buff i value; - ok
      call "mov" buff.arr[i] value; - not ok
    }
    next:
    {
      call "inc" i i
      jmp loop
    }
    nop
    end:
  }
  ret buff
}

vec2i "vec2i"(int x,int y)asm
{
  var vec2i tmp
  call "mov" tmp.x x
  call "mov" tmp.y y
  ret tmp
}

int "func_name"(int x,int y)asm
{
  var int s
  {
    call "sum" s x y
    call "inc" s s
    call "add" s s 10
    {
      var char u 'h'
      var vec2i v
      call "vec2i" v 0 0
    }
  }
  ret s
}

bit "get_bit"(int value,int id)asm
{
  var bit b
  call "mov" b value[id]
  ret b
}

вообще я могу обойтись без mov вообще.
он мне нафиг не нужен. я могу сам сделать встроенную в интепретатор функцию которая будет
для определённого типа операндов делать то что требуеться.
минусы?
это будет медленее интепретировать чем mov .
дело в том, что вызов инструкции дешевле вызова функции на порядки.
но моя задача по разработке умного асм языка не в том, чтобы обеспечить высокую скорость интепертации,
а в том, чтобы обеспечить высоку скорость разработки:
  оптимизатора для этого языка.
  транслятора для этого языка.

это промежуточный язык и у него не стаит такой задачи как высокая скорость интепретации. вот так вот!
неожиданный поворот. :)

тут используеться инструкция мов которая перемещает один бит из 32-битного числа в однобитный регистр.
тоесть она принимает вторым параметром число, а третим параметром - индекс бита.
тоесть тут всё немного странное с третим параметром у негоразделитель не такой как у остальных
параметров
поэтому два параметра воспринимаються как один составной, но это не так.
а как тогда объяснить работу с полями объектов?
я всё ещё буду доказывать отсутсвие выражений или всё так и буду пытаться доказать,
что вот это:
arr[0].arr[2].x.arr[3]
тоже всего-лишь спецальная инструкция с кучей спецально оформленых параметров?
может уже просто признать что у меня в асм языке есть какие-то выражения?
и что эти выражения можно транслировать в набор простых инструкций со странно оформленными параметрами.
блин мне сейчас придёться писать спецальную лексему которая должна разбирать вот эти выражения.
но я могу просто сделать нексоклько особых инструкций мов и тогда мне не придёться разбирать эти
выражения прямо сейчас,но тогда язык будет немного ужербным и мне придёться писать лишние команды.
которые к тому же будут копировать массивы туда сюда незнаю зачем.
но вообще как никрути а где-то всё равно придёться копировать массивы туда сюда.
вопрос только в том, где это делать.
либо пряма в асме указывать, либо интепретатор будет их туда сюда копировать.
и так будет продолжаться до тех пор пока я наконец-то не напишу оптимизатор.

для первого приблежения:
{
  запретить вот такие выражения:
  mov b arr[1][2][3]
  mov b v.v.x
  mov b v.arr[0].x.z

  разрешить вот такие:
  mov b value[0]
  mov x v.x
}

итак. оказываеться что имя регистра - это страка.
так что получаеться что один фиг что имя регистра что имя поля для регистра структуры типа.
виды выражений которые можно передать как параметр в call инструкцию:
регистр
регистр.поле_структуры - да это типа один параметр.
число
символ
строка
флаг

пока всё.
потом можно будет ещё что-то добавить.
а для начала вообще сделаю только число. остальное - нафиг-нафиг.

вообще получаеться в моём асме инструкция call - не инструкция, а костыль.
вообще в этом моём асме вообще нет инструкций.
есть только костыли.
ну так вот, все костыли как костыли, а call - самый высокоуровневый костыль.
короче он зараза большую часть тупого кода прячет.
он же обабщает код больше других костылей.
собственно я бы сказал что весь асм построен вокруг этого call-костыля.
тоесть его можно назвать основой всего языка - а всё остальное - это перефферия.
тоесть большая часть всего кода - это последовательность call`ов.
вот так вот.

что всё меня опять понесло отдыхать? а код кто писать будет?
ладно а чё надо какой-то код писать?
ну что я ещё не сделал?
ВОВ! 7434 символа уже нафигачил в этот файл. немало так.
и это ещё не всё!

можно работать со стуктурами и массивами. и это хорошо.
вот эта инструкция странная:
mov x v.x
дело в том, что она принимает:
первый параметр регистр
второй - регистр
а третий - особая_строка.


вот такие ограничения сделают интепретатор проще, а код избыточнее.
потом во втором приблежении можно будет подумать об этом всё ещё раз. а на сегодня достаточно этого.
итак. я согласился в параметрах инструкций ограничить сложность выражений.



t_reg_expr=>i_expr{
  t_field=>i_ext{
    string field;
    {
      go_const(".");
      go_str<t_name>(field);
    }
  }
  t_id=>i_ext{
    t_num=>i_case{
      string value;{go_str<t_number>(value);}
    }
    t_reg=>i_case{
      string value;{go_str<t_name>(value);}
    }
    TAutoPtr<i_case> idexpr;
    {
      go_const("[");
      go_str<t_name>(idexpr);
      go_const("]");
    }
  }
  string name;
  TAutoPtr<i_ext> ext;
  {
    M+=go_str<t_name>(name);
    O+=go_auto(t_field);
  }
}

t_int_expr=>i_expr{
  string value;
  {
    go_str<t_number>(body);
  }
}

t_call_stat=>i_stat{
  t_params{
    vector<t_name> arr;
    {
      go_const(" ");
      go_vec(arr," ");
    }
  }
  t_string func;
  TAutoPtr<i_expr> out;
  t_params params;
  {
    M+=go_const("call");
    M+=go_const(" ");
    M+=go_auto(out);
    O+=go_auto(params);
  }
}

t_block_stat=>i_stat{
  t_block body;
  {
    go_auto(body);
  }
}

t_var_stat=>i_stat{
  t_type type;
  t_name name;
  {
    go_const("var");
    go_const(" ");
    go_auto(type);
    go_const(" ");
    go_auto(name);
  }
}

t_sep_stat=>i_stat{
  t_sep sep;
  {
    go_auto(sep);
  }
}

t_block{
  vector<TAutoPtr<i_stat>> arr;
  {
    M+=go_const("{");
    O+=go_auto(arr);
    M+=go_const("}");
  }
}

t_params{
  string type;
  string name;
  {
    M+=go_str<t_type>(type);
    M+=go_const(" ");
    M+=go_str<t_name>(name);
  }
}

t_func_node=>i_node{
  string type;
  t_string name;
  t_params params;
  t_sep sep;
  t_block code;
  {
    M+=go_str<t_type>(type);
    M+=go_const(" ");
    M+=go_auto(name);
    M+=go_const("(");
    O+=go_auto(params);
    M+=go_const(")asm");
    O+=go_auto(sep);
    M+=go_auto(code);
  }
}

t_struct_node=>i_node{}
t_comment_node=>i_node{}

t_asm_scope{
  vector<TAutoPtr<i_node>> arr;
}





















короче это очень похоже на мой текущий скриптовый С++ подобный язык, но с тем исключением,
что тут на один статамент всего один вызов функции.
это основная особенность этого языка.
точнее это соновная особенность всех асм-подобных языков.
они делают вызов всего одной функци на один статамент.
и это очень удбно.
это увеличивает скорость интепретации.
хотя... стоп! увеличивает ли?
помоему опять получиться тормозно.
всё дело в том, что по имени функции по прежнему не возможно понять что вызывать.
поэтому пидёться определять типы параметров.
тоесть придёться во время интерпретации тратить на это время.
тоесть короче это бедет всё ещё медленный язык.
возможно даже медленее чем предыдущий.
а пофиг. всё равно этот язык ближе к нативным языкам чем с++ подобный скрипт.
короче у меня есть такое пока не обосновоное мнение, что скрипт на этом асм подобном языке легче оптимизировать чем
на с++ подобном.
короче этот язык вроде как можно запросто конвертнуть в ещё более близкий к железу асм.
например выкинув типы и умный call вообще.
это должно будет дать прирост скорости интепретации.
вот поэтому я и пишу этот скриптовый язык.