есть идея устроить платный конкурс среди пользователей программы.самый лучший пользователь получит приз.программу можно сделать платной.+++сделать форму регистрации ввиде обычного текста который можно  скпировать целиком. хорочая идея нет?+++ребят нужна помощь.короче я сел писать парсер и теперь у меня нет сил его дописать.там какой-то суровый запар с синтаксисом объявления переменных через запятую.я уже даже вроде всё написал, но чего-то не хватает.короче я два раза подрят пытался осилить эту задачу, но на третий раз меня уже не хватило, я уже просто тупо начал симулироватьбурную деятельность.я просто не могу решить эту задачу за пол часа. даже за три часа не могу.объязательно какая-то лажа получиться. кто-то отвлекёт из-за какой-то херни и все дела коту под хвост.выкладывай задачу я помогу.забей.запиши видео того как ты её решаешь.попробуй ещё раз, ты смышлёный парень у тебя всё получиться.не сдавайся! добей эту задачу.+++я сейчас помню две задачи:пилить лексер.делать игру.игра компилируеться три минуты.это блин не выносимо.лексер нужен чтобы уменьшить время компиляции.игру нужна чтобы заработать денег.деньги нужны, чтобы не ходить на работу.не ходить на роботу нужно для того, чтобы делать свои проекты.свои проекты нужно делать для того, чтобы сильно помочь человечеству.помочь человечеству потому что оно офигенно.делать лексер офигенно выгодно.я буду им пользоваться очень много раз и он с экономит мне просто гиганское количество времени.то кол-во времени которое я потратил на его разработку полная фигня по сравнению с тем, сколько времени он мне с экономит.и это экономия времени позволит мне делать проекты наголову круче чем сейчас.+++инструмент для голосования.куча народу.распределённый софт который позволяет группе народа без накрутки за что-то анонимно голосовать.вход исключительно по приглашениям.+++есть лексема храящая пробел.есть лексема хранящая функцию.иногда лексема хранащая функцию жрёт пробел перд собой.тоесть у нас конфликт лексем.но он не всегда.иногда лексема хранящая функцию не ест пробел.например если есть квалификатор типа inline или static.решение:строго настрого запретить читать сепаратор перед лексемой.это правило распространяеться и на те лексемы которые внутри нашей.если придерживаться этого правила, то тогда небудет конфликтов.короче всё дело было в опциональной лексеме которая не ела разделитель.и ещё была обязательная лексема которая ела перед собой разделитель.элементы вектора поедают разделиитель с двух сторон.но только в том случае если их используют как go_vec.если как go_auto, то правило сохраняется.+++сделать конвертор струтур из одного формата в другой.// в процессесделать для тестирования TIsSameVisitor загрузку кода теста из файла. //готово.+++я захотел уменьшить время компиляции{  надо распарсить с++.// готово  надо ументь сохранять лексему игнорируя квалификторы опциональности.  {    это задача. // с первого раза не удалось решить.  }}можно просто сделать дополнительный метод в каждой лексеме который будет сохранять все поля игнорируя опциональность.мне надо выполнить метод go лексемы игнорируя опциональность.{  можно при генерации C++ кода сделать два метода go  {    в два раза больше кода? да. в два разо дольше компиляция.    придёться перегенерировать все классы лексем.    выглядит как копипаста.    зато оригинальный метод go будет таким же быстрым.    это реально сделать за день. это не так сложно как интерпретатор. любой нубсправиться с этой задачей.  }  можно просто добавить в i_dev спец флаг который будет игнорировать опциональность.  {    это реально просто.    это решит текущую проблемму.    я сразу же вернусь к написанию конверторов/интепретатороа/компилаторов/прасеров С++ кода.    это может замедлить производительность?    что-то у меня подозрение, что это вообще нельзя сделать.    флаг храниться внутри t_fallback    t_fallback жоско зашит внутри каждого метода.    выход:    {      можно сделать метод go шаблонным. //плохая идея.      можно изменить t_fallback так, чтобы он вызывал спецальный метод "dev.is_without_optional()" // удар по производительности даже в том случае когда это нафиг не надо.      на каждый чих изменять имплементацию t_fallback - это путь в никуда.    }  }  можно сделать интерпретатор лексем + особый интерпретатор лексем.  {    от этого можно получить дополнительную выгоду. можно будет не компилируя С++ код интерпретировать лексемы.    чуть раньше или чуть позже, но я всё равно это сделаю.  }}нам нужен исходник метода go лексемы.{  можно добыть исходник лексем, а в нём найти нашу лексему  {    можно загрузить фалй-исходник лексем.    можно сделать функцию которая вернёт исходник лексем как std::string  }  можно в класс каждой лексемы встроить метод который будет возврящать std::string c исходником её метода go.}с одной сторый интепретация это хорошо, а с другой стороны это медленно.это медденно компилируеться.это медленно выполняеться.в дебаге распарсить исхожник лексем - это долго.но я ничего не могу с этим поделать.самя курять - это иметь под ругой такой интепретатор.я смогу описывать лексемы во время выполнения и затем по этому описанию парсить текст.можно будет обнаруживать ошибки в описании лексем ещё на этапе разработки.это всё очень здорово.блин. из-за этого дурацкого метода у меня время компиляции увеличиться.зато с другой стороны я смогу кономить время затрачиваемое на проверку описания лексем.но я не так много пиши и проверяю лексемы. если я доделаю интепретатор, то тогда смогу быстрее разрабатывать лексемы.ладно. есть идея для начала немного пострадать.я предполагаю, что мне не так уж и много надо сохранять лексем игнорируюя опциональность.мне это ещё совсем не выбесило, а я уже испугался.может я смогу уследить за этим вручную.надо попробовать разрулить эту задачу вручную.мне надо не так уж и много конверторов.вообще приходиться писать коверторы не от добра.если бы компилятор компилировал быстро, тогда мне бы не нужен был бы конвертор.