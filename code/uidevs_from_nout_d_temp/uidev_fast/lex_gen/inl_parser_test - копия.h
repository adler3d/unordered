struct trololo{typedef /*;*/ int fail;};void formal(...);class IProduct{  virtual void fooo()  {    if (bool(*this))Free();  }public:public:  typedef IProduct SelfClass;public:  typedef IProduct NextOwnerClass;public:public:  void DoReset();public:  IProduct(const IProduct&)=delete;  IProduct();public:  IProduct(IProduct&&_Right);  void operator=(IProduct&&_Right);public:  struct ProxySys$$  {    typedef TTypeStruct metatype;    template<class QAP_RTTI>    static metatype*GetRTTI(QAP_RTTI&RTTI);    static string GetFullName();  };public:public:  virtual void safe_free()  {    if (bool(*this))Free();  }public:  virtual const TMemory&GetMemory()const  {    QapDebugMsg("no way.");    return *(TMemory*)nullptr;  }  virtual TMemory&GetMemory()  {    QapDebugMsg("no way.");    return *(TMemory*)nullptr;  }  virtual IAllocator*GetAlloc()  {    QapDebugMsg("no way.");    return nullptr;  }  virtual IFactory*GetFactory()  {    QapDebugMsg("no way.");    return nullptr;  }  virtual TType*GetType()  {    QapDebugMsg("no way.");    return nullptr;  }public:  void Init()  {    weak_Init<0>();  };  template<int>void weak_Init()  {    TMemory&Memory=GetMemory();    IAllocator*pAlloc=GetAlloc();    IFactory*pFactory=GetFactory();    QapAssert(!Memory);    QapAssert(pAlloc&&pFactory);    pFactory->Init(pAlloc,Memory);  }  struct {};  void Free()  {    weak_Free<0>();  };  template<int>void weak_Free()  {    TMemory&Memory=GetMemory();    IAllocator*pAlloc=GetAlloc();    IFactory*pFactory=GetFactory();    QapAssert(Memory);    QapAssert(pAlloc&&pFactory);    pFactory->Free(pAlloc,Memory);    QapAssert(!Memory);  }  operator bool()const  {    return bool(GetMemory());  }};class A{};class B{};class C:public A,public B{};struct D;class E;struct D{};class E:D,A,B{};class TMemory{public:  struct {};  struct ptr_t {};  ptr_t*ptr;  int size;  TMemory():ptr(nullptr),size(0) {}  //TMemory(ptr_t*ptr,int size):ptr(ptr),size(size){}  //TMemory(int size,void*ptr):ptr(ptr),size(size){}  operator bool()const  {    QapAssert(bool(ptr)==bool(size));    return ptr;  }  void operator=(nullptr_t)  {    ptr=nullptr;    size=0;  }  void operator=(TMemory&&_Right)  {    ptr=_Right.ptr;    _Right.ptr=nullptr;    size=_Right.size;    _Right.size=0;  }};const::std::string foo16_first();static const string get_string();int const&abc();int *const*const&bca();void foo();::std::array<int,16>foo6_0();::std::vector<std::vector<int*>**>*&foo0();vector<int>foo1();std::vector<int>foo2();std::vector<int> foo2a();::std::vector<int>foo3();::std::vector<int> foo3a();::std::vector<int>/*some text here*/foo3b();//typedef int t; template<class T>using vec = vector<T>;::vec<map<::t,::t>::value_type>::value_type foo4();::std::vector<std::vector<int*>**>*foo5(); :: std :: vector < std :: vector < int * > * * > * foo5_a (); :: std ::/*before vector*/vector </*before std*/std :: vector </*before int*/int * > * * > * foo5_b ();  //foo5_c(   :: std    ::   ector <std :: vector <   int * > * *    > * foo5_c   (); //)foo5_c ::std::array<int,16>foo6();::std::array<int*,16>foo7();::std::array<int*,16>*&foo8();::std::array<const int*,16>*&foo8a();::std::array<const/*pocpocpoc*/int*,16>*&foo8b();::std::array<const/*pocpocpoc*/int*const*,16>*&foo8c();int*foo9();int const*foo10();int const foo11();int*const foo12();int const*&foo13();int const*const&foo14();int const*const&&foo15();const::std::string foo16();const ::t*foo17();//...//int f()[10];struct t_test{  explicit t_test(); ~t_test();  virtual const string operator()(int)const=0;};