class THiAllClass{public:#define DEF_PRO_STRUCT_INFO(NAME,PARENT,OWNER)NAME(THiAllClass)#define DEF_PRO_VARIABLE(ADDBEG,ADDVAR,ADDEND)\ADDBEG()\ADDEND()//=====+>>>>>THiAllClass#include "QapGenStruct.inl"//<<<<<+=====THiAllClasspublic:  bool go(i_dev&dev)  {    return false;  }  struct t_poly_impl:public t_poly_tool::go_poly<SelfClass>  {    #include "QapLexPolyBeg.inl"    template<int>    bool load()    {      return false;    }    #include "QapLexPolyEnd.inl"  };  //static string GetClassMetaSpecInfo(){return get_impl_specinfo<SelfClass>();}  static string GetClassMetaSpecInfo(){return get_poly_specinfo<SelfClass>();}};struct t_impl_for_unsafe_toStr{  struct t_foo{bool (t_impl_for_unsafe_toStr::*pfunc)(i_dev&dev);};};template<class TYPE>string unsafe_toStr(IEnvRTTI&Env,TYPE&ref){  string out;  t_save_dev dev(Env,out);  void*pValue=&ref;  TTypeStruct*pType=Sys$$<TYPE>::GetRTTI(Env);  QapAssert(!pType->extInfo.SpecInfo.empty());  auto&arr=pType->Members;  for(int i=0;i<arr.size();i++)  {    auto&ex=arr[i];    auto*ptr=ex.getValue(pValue);    auto*pt=ex.Type.get();    if(auto*ps=TTypeStruct::UberCast(pt))    {      auto&si=ps->extInfo.SpecInfo;      QapAssert(!si.empty());      auto head="impl:";      if(is_first_part_of(si,head))      {        auto ext=without_first_part(si,head);        auto pointer=HToI(ext);        t_impl_for_unsafe_toStr::t_foo foo;        (int&)foo=pointer;        auto*pobj=(t_impl_for_unsafe_toStr*)ptr;        (pobj->*foo.pfunc)(dev);        continue;      }      QapNoWay();      continue;    }    if(auto*p=TTypeAutoPtr::UberCast(pt))    {      QapDebugMsg("type:\n"+p->GetFullName());    }    if(auto*p=TTypeVector::UberCast(pt))    {      int fail=1;      /*полный провал. нерешаемая проблема. мы получаем вектор. а вот что с ним делать.       мы же не знаем что за операция к ниму применяеться.        у нас нет этой информации.        иливот например строка. вдруг это go_str или go_end. вот отсюда куча проблем.        короче единственное правильное решение - это хранить весь ход метода в specinfo.        тогда можно будет понять для чего нужно каждое поле и как его сохранять.*/      QapAssert(false);    }    if(auto*p=TTypeSys::UberCast(pt))    {      if(p->BinIO.get()!=THeadBinIO<string>::Get())      {        QapDebugMsg("type:\n"+p->GetFullName());      }      auto&s=*(string*)pValue;      bool ok=dev.go_const(s);      QapAssert(ok);    }    QapNoWay();  }  int gg=1;  return out;}void empty_unit_test(IEnvRTTI&Env){  t_inl_file inp;  load_obj_full(Env,inp,"struct ttt{typedef ttt*pttt;};");  unsafe_toStr(Env,inp);}